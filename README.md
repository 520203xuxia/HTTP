# 本文将从以下几个方面学习Http
	* 一、什么是Http？

	* 二、Http协议发展历史
	
	* 三、Http状态码
	
	* 四、Http缓存的重要性
	
	* 五、缓存规则

	* 六、Http响应头和请求头
	
	* 七、Https


# 一、什么是Http？
	1.（HyperText Transfer Protocol，超文本传输协议是用于从万维网（WWW:World Wide Web）服务器传输超文本到
	本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
	2. 它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程，默认使用80端口。
	3. 客户端连上web服务器后，若想获得web服务器中的某个web资源，
	   需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。
	4. HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。
	Web服务器根据接收到的请求后，向客户端发送响应信息。

# 二、Http协议发展历史
![history](https://github.com/520203xuxia/HTTP/raw/master/img/http-history.jpg)

## 1. Http/0.9
	该版本极其简单，只有一个命令GET。
	GET  /index.html
	上面命令表示，TCP连接建立后，客户端向服务器请求网页index.html
	协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式
	服务器发送完毕，就关闭TCP连接。
## 2. Http/1.0
**该版本内容大大增加。**

	* 任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。
	这为互联网的大发展奠定了基础。

	* 除了GET命令，还引入了POST、HEAD命令，丰富了浏览器与服务器的互动手段。

	* HTTP请求和回应的格式，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一
	些元数据。

	* 其他新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part 
	type）、权限（authorization）、缓存（If-Modified-Since,Expires）、内容编码（content encoding）等。


	缺点：
	主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，
	就必须再新建一个连接。

	TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）
	。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

## 3. Http/1.1
	仅比Http/1.0 版本晚了半年，一直用到了今天，直到现在还是最流行的版本
	该版本的变化：

	* 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection:Keep-alive。

	* 引入更多的缓存控制策略例如Entity tag，If-modified-Since, If-Match, If-None-Match等

	* 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在
	最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。目前，对于同一个域名，
	大多数浏览器允许同时建立6个持久连接。

	* 引入管道机制。即在同一个TCP连接里面，客户端可以同时发送多个请求。

	* 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是
	Content-length字段的作用，声明本次回应的数据长度，后面的字节就属于下一个回应了。

	* 使用Content-Length字段的前提是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时
	的操作，意味着服务器要等所有操作完成，才能发送数据，显然这样效率不高，更好的处理方法是，产生
	一块数据，就发送一块。Transfer-Encoding：chunked 字段表面回应将由数量未定的数据块组成。

	* 还增加了许多方法：PUT、PATCH、HEAD、OPTIONS、DELETE。

	* 新增Host字段，用来指定服务器的域名，不能缺，但是可以是空值。有了Host字段，就可以将请求发往
	同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。


	缺点：
	虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理
	完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为
	"队头堵塞"（Head-of-line blocking）。

## 4. SPDY协议
	2009年，谷歌公开了自行研发的SPDY协议，主要解决HTTP/1.1效率不高的问题。
	这个协议在Chrome浏览器上证明可行以后，就被当作HTTP/2的基础，主要特性都在HTTP/2 之中得到继承

## 5. Http/2
**新增的功能**

	* 二进制协议。此版本是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”：头信息帧
	和数据帧。

	* 多工。双向的、实时的通信。HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多
	个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

	* 数据流：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
	因此，必须要对数据包做标记，指出它属于哪个回应。	HTTP/2 将每个请求或回应的所有数据包，称为一
	个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用
	来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。
	数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消
	数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，
	可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

	* 头信息压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，
	比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
	HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip
	或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，
	生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

	* 服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
	常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，
	解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，
	很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

	**HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？**

		- HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

		- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，
		一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

		- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行

![connection-diff](https://github.com/520203xuxia/HTTP/raw/master/img/connection-diff.jpg)

# 三、Http状态码
	1xx：指示信息---表示请求已接收，继续处理
			100：Continue 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。
			客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。
			101：服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求

	2xx：成功---表示请求已被成功接收并处理
			200：表明请求成功完成，所有资源成功发送给客户端
			201：请求已经被实现，而且有一个新的资源已经依据请求的需要而创建
			202：服务器已接受请求，但尚未处理
			204：服务器成功处理了请求，没有返回任何内容

	3xx：重定向---要完成请求必须进行更进一步的操作
			301：永久重定向
			302：临时重定向
			304：有缓存，且未失效，从本地获取

	4xx：客户端错误---请求有语法错误或请求无法实现
			400：客户端请求有语法错误，不能被服务器解读
			403：服务器拒绝服务（例：http://ehall.szu.edu.cn/new/index.html）
			404：请求失败，请求的资源在服务器上没有找到

	5xx：服务器端错误---服务器未能实现合法的请求
			500：服务器端错误，一般是服务器端代码出错

# 四、Http缓存的重要性
	  Http缓存是Web性能优化的重要手段

# 五、缓存规则
## 1. 强制缓存
![compulsion-cache](https://github.com/520203xuxia/HTTP/raw/master/img/compulsion-cache.jpg)

	缓存如果未失效，则直接使用缓存数据。那么怎么判断缓存是否失效呢？
	Http 响应header中，有两个字段标明失效规则：
	* Expires：服务器返回的到期时间，HTTP 1.0的东西，基本忽略它的作用
	* Cache-Control：很重要的规则，默认值为private
		private:		客户端可以缓存
		public:	   		客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
		max-age=xxx:	缓存的内容将在 xxx 秒后失效
		no-cache:       需要使用对比缓存来验证缓存数据
		no-store:       所有内容都不会缓存，强制、对比缓存都不会触发

强制缓存生效时：

![compulsion-cache-example.jpg](https://github.com/520203xuxia/HTTP/raw/master/img/compulsion-cache-example.jpg)

## 2. 对比缓存
![contrast-cache](https://github.com/520203xuxia/HTTP/raw/master/img/contrast-cache.jpg)

	* 对比缓存，需要进行比较判断是否可以使用缓存。
	* 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户 端，客户端将二者备份至缓存数据库中。
	* 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

	对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递：

	1.	Last-Modified  /  If-Modified-Since
		Last-Modified：
		服务器在响应请求时，告诉浏览器资源的最后修改时间。

		If-Modified-Since：
		再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。

	2.	Etag/If-None-Match（优先级高于Last-Modified/If-Modified-Since）
		Etag：
		服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）

		If-None-Match：
		再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。


两类缓存规则的不同：
* 强制缓存如果生效，不需要再和服务器发生交互。
* 对比缓存不管是否生效，都需要与服务端发生交互。
* 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存。

	 - **对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。**

	 - **对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存**

注意看下图中，Size这一列的三个状态：from memory cache、from disk cache、资源大小，那么三种的区别在哪里？

![Size](https://github.com/520203xuxia/HTTP/raw/master/img/Size.png)

	from memory cache： 不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill
	进程后，数据将不存在

	from disk cache： 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。

	资源本身大小数值： 当http状态为200是实实在在从服务器获取的资源，当http状态为304时该数字是与服务端通信
	报文的大小，并不是该资源本身的大小，该资源是从本地获取的。

	以 https://bloag.csdn.net/garrettzxd/article/details/80684880 网页举例分析

	这篇文章解释的不错: https://www.cnblogs.com/beidan/p/cache.html
									 https://blog.csdn.net/huantuo4908/article/details/70313165

# 六、Http响应头和请求头
	了解一下 URL/URI
	URL:
		protocol://host:port/path?query#ref
	- protocol:获取资源使用的协议
	- host:主机名，也可以是ip
	- port:端口号
	- path:主机上的文件路径
	- query:通过get方式请求的参数
	- ref:定位

	URI:
		scheme://user:password@host:port/path;params?query#fragment
	- scheme:获取资源使用的协议
	- user:password：用户名与密码，一般访问ftp时会用到，可不写
	- host:主机名，也可以是ip
	- port:端口号
	- path:主机上的文件路径
	- params:很少见，主要作用就是像服务器提供额外的参数，用来表示本次请求的一些特性
	- query:通过get方式请求的参数
	- fragment:定位


http/2定义了一些以":"开始的头部字段，用来携带一些请求目标的信息

![request-header-2.0](https://github.com/520203xuxia/HTTP/raw/master/img/request-header-2.0.png)

## 1. 请求头（Request Headers）
**Host**： 请求报头域主要用于指定被请求资源的Internet主机和端口号，必须值

**Accept**：浏览器可以接受的媒体类型（text/html、\*\/\*）

**Accept-Encoding**：浏览器声明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法(gzip，deflate)

**Accept-Language**：浏览器声明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等（Accept-Language:en-us）

**Connection**：keep-alive，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。如果是Connection：close，代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次放松Request，需要重新建立TCP连接。

**User-Agent**：告诉服务器，客户端使用的操作系统和浏览器的名称和版本。

**Referer**： 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里,他的服务器就能够从HTTPReferer中统计出每天有多少用户点击我主页上的链接访问他的网站。

**Cookie**：用来存储一些用户信息以便让服务器辨别用户身份的。

**Cache-Control**：通用首部字段。 我们网页的缓存控制是由HTTP头中的“Cache-control”来实现的，常见值有private、no-cache、max-age、must-revalidate等，默认为private。

**If-Modified-Since**： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。

**If-None-Match**： If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能。

**origin**：发起一个针对跨域资源共享的请求

## 2. 响应头（Response Headers）
**Server**：响应客户端的服务器。

**Date**：响应的时间。

**Connection**：keep-alive，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。如果是Connection：close，代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次放松Request，需要重新建立TCP连接。

**Pragma**：HTTP 1.0的遗留物，值为”no-chche“时禁用缓存

**ETag**：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识

**Expires**：为服务端返回的到期时间，即下一次请求时，请求时间小于服务器返回的到期时间，直接使用缓存数据，但这是HTTP 1.0的东西，现在浏览器默认使用HTTP 1.1，所以他的作用基本忽略。

**Cache-Control**：通用首部字段。private|public|no-cache|max-age|no-store，默认为private


   - private：客户端可以缓存

   - public：客户端和代理服务器都可缓存（对前端开发者来说，认为public和private是一样的）

   - max-age=xxx：缓存的内容将在xxx秒后失效

   - no-cache：内容会被缓存，只是每次使用都需要向服务器验证其有效性

   - no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发（但对于前端开发来说，缓存越多越好，所以这个值基本不用）

**Last-Modified**：服务器在响应请求时，告诉浏览器资源的最后修改时间。

**Content-Type**：响应正文的类型。（图片还是二进制字符串）

**Content-Length**：响应正文长度。

**Content-Charset**：响应正文使用的编码。

**Content-Encoding**：响应正文使用的数据压缩格式

**Content-Language**：响应正文使用的语言

**Access-Control-Allow-Origin**：指定哪些网站可以跨域源资源共享，只能有一个值

**Access-Control-Allow-Methods**：允许的请求类型，多个用逗号隔开



	请求头和相应头中都有Cache-Control字段，有什么区别？

	响应头中的这个属性是服务器端告诉客户端应该怎么做，做不做还是决定于客户端。

	如何理解请求头中Cache-Control：max-age=0，而响应头中Cache-Control：max-age=3600?

	客户端强制要求服务端返回最新文件，响应头中是服务器端告诉客户端，该文件在3600s内不用再向服务
	器端请求了。但如果请求头下次请求时该字段值为max-age=0，则就必须由服务器返回最新文件。

	响应头中Cache-Control：max-age=0。代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务
	器进行一遍通信，将etag、If-Not-Modified等字段传递给服务器以便验证当前浏览器端使用的文件是否
	是最新的（如果浏览器用的是最新的文件，http状态码返回304，服务器告诉浏览器使用本地缓存即可；
	否则返回200，浏览器得自己把文件重新下载一遍）。

# 七、Https
## 1. 基础概念
	全称：Hyper Text Transfer Protocol over Secure Socket Layer，以安全为目标的HTTP通道.HTTPS使用端口443。
	HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的
	信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。
## 2. 出现原因
		为了敏感信息不被第三方获取
## 3. SSL/TLS
	SSL(Secure Sockets Layer)，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。为啥
	要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被
	偷窥和篡改。发明 SSL 协议，就是为了解决这些问题。

	到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之
	后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
	很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。

## 4. 对称加密
	加密和解密用的是同一个秘钥。
### 优点：
		速度快，对称性加密通常在消息发送方需要加密大量数据时使用，算法公开、计算量小、加密速度快、加密效率高。
### 缺点：
		在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息
		也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所
		拥有的钥匙数量巨大，密钥管理成为双方的负担。

## 5. 非对称加密
	加密解密用的是不同的秘钥，遵循的原则：公钥加密，私钥解密。（不可以私钥加密，公钥解密）
	公钥可以公开，但私钥是服务器私有的，只要没有泄露，传输都是安全的。因为公钥加密的数据，只有私钥才能解开。
### 优点：
		安全
### 缺点：
		速度较慢

	具体原理请参照阮一峰的文章：
		http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
		http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html

1. 客户端发起HTTPS请求
就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

2. 服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3. 传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4. 客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5. 传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. 服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. 传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原

8. 客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

SSL的位置
SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。

对称与非对称加密结合：

![对称与非对称加密结合](https://github.com/520203xuxia/HTTP/raw/master/img/对称加密.jpg)










